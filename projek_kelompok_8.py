# -*- coding: utf-8 -*-
"""Projek Kelompok 8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rrwLDKfy6tUdwt7yG2IXdEwQTaQszfwR
"""

#Import Library

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
#from pandas.tseries.offsets import MonthBegin
#https://data.jakarta.go.id/dataset/data-penumpang-bus-sekolah-tahun-2019-kpi
#from google.colab import files
#uploaded = files.upload()

"""**DATA UNDERSTANDING (Mengumpulkan Data)**"""

#Memanggil dataset
df = pd.read_csv('https://query.data.world/s/7dqaqpt6bymjvjyawwty3pebm32ysm')

# Menghilangkan kolom yang tidak diperlukan
bensin = df[["ExtractDate","Fleet","Vehicle","Fuel","Dist.Run","MPG","Type"]]

# lalu tampilkan 
bensin

# melihat jumlah baris dan jumlah kolom (bentuk data) pada data df dengan fungsi .shape 
bensin.shape
#Data kita mempunyai 26 kolom dengan 205 baris.

#Memanggil data pertama
bensin.head()

#Memanggil data terakhir
bensin.tail()

#Memanggil tipe-tipe data
bensin.info()

#Memanggil informasi statistik data
bensin.describe()

"""**DATA PREPARATION (Menelaah Data)**

**Data Cleaning (Pembersihan Data)**
"""

#Konversi 'Fuel' Float to Int
bensin["Fuel"] = bensin["Fuel"].astype("int")

#Konversi 'MPG' Object to float
bensin['MPG'] = pd.to_numeric(bensin['MPG'], errors='coerce')

#Cek tabel Dist.Run
bensin.loc[:,'Dist.Run'].head(10)

#Menggunakan Regex
regex = r'^(\d{4})'

extr = bensin['Dist.Run'].str.extract(r'^(\d{4})', expand=False)
extr.head()

bensin['Dist.Run'] = pd.to_numeric(extr)
bensin['Dist.Run'].dtypes

bensin['Dist.Run'].isnull().sum()/len(bensin)

#Konversi 'Dist.Run' Object to float
bensin['Dist.Run'] = pd.to_numeric(bensin['Dist.Run'], errors='coerce')

#Cek Tipe Data
print(bensin.dtypes)

#Handling missing value
bensin.isnull().sum()

#Mengisi nilai nan dengan menggunakan metode 'ffill'

bensin1 = bensin.fillna(method='ffill')
display(bensin1)

#Cek keberadaan missing value setelah imputasi
display(bensin1.isna().sum())

#Konversi 'MPG' Float to Int
bensin1["MPG"] = bensin1["MPG"].astype("int")
bensin1.dtypes

#Konversi 'Dist.Run' Float to Int
bensin1["Dist.Run"] = bensin1["Dist.Run"].astype("int")
bensin1.dtypes

#Hasil Akhir Pembersihan Data
bensin1

"""**Data Modeling (Memanipulasi dan Menyimpulkan Data)**

**Handling Outlier**
"""

#Tampilkan Boxplot masing-masing kolom berisi data kuantitatif sebelum handling outlier
#Jenis plot yang digunakan adalah boxplot seaborn
#Melihat adanya pencilan menggunakan Boxplot (Sebelum hapus outlier):
sns.set_theme(style="white")


plt.figure(figsize=(10,5))

for i, col in enumerate(bensin1.describe().columns) :
    plt.subplot(2,3, i+1)
    sns.boxplot(x=bensin1[col])
    plt.tight_layout()

plt.show()

#Hilangkan Outlier dan tampilkan dataframe hasil menghilangkan outliernya

def index_outliers(dframe):
    
    outliers_index = []
    for col in dframe.describe().columns:
        Q1 = dframe[col].quantile(0.25)
        Q3 = dframe[col].quantile(0.75)
    
        IQR = Q3-Q1
    
        lower_limit = Q1-(1.5*IQR)
        upper_limit = Q3+(1.5*IQR)
    
        outliers = dframe[ (dframe[col]<lower_limit) | (dframe[col]>upper_limit) ].index
        outliers_index.extend(outliers.to_list())
    
    outliers_index = set(outliers_index)  #Convert to set to remove duplicate numbers
    outliers_index = list(outliers_index) #Convert the set back to list
    
    outliers_index.sort()                 #Sort the list
    
    return outliers_index

index_outliers(bensin1)

outlier = index_outliers(bensin1)
bensin1.drop(outlier, inplace=True)

#Data frame setelah menghapus outlier:
bensin1

#Tampilkan Boxplot masing-masing kolom berisi data kuantitatif sesudah handling outlier
#Melihat adanya pencilan menggunakan Boxplot (Setelah hapus outlier):
plt.figure(figsize=(10,5))

for i, col in enumerate(bensin1.describe().columns) :
    plt.subplot(2,3, i+1)
    sns.boxplot(x=bensin1[col])
    plt.tight_layout()
    
plt.show()

"""**Select Modeling Technique (Memilih teknik model)**"""

#Vehicle dengan MPG menggunakan barplot
sns.set({'figure.figsize':(8,8)})
bensin5 = bensin1[['Vehicle','MPG']].groupby('Vehicle', as_index=False).sum().melt(id_vars='Vehicle')
sns.barplot(x='value', y='Vehicle', hue='variable', data=bensin5)

#Vehicle dengan Fuel menggunakan barplot
sns.set({'figure.figsize':(8,8)})
bensin5 = bensin1[['Vehicle','Fuel']].groupby('Vehicle', as_index=False).sum().melt(id_vars='Vehicle')
sns.barplot(x='value', y='Vehicle', hue='variable', data=bensin5)

#Vehicle dengan Dist.Run dan Fuel menggunakan barplot
sns.set({'figure.figsize':(13,13)})
bensin4 = bensin1[['Vehicle', 'Dist.Run', 'Fuel']].groupby('Vehicle', as_index=False).sum().melt(id_vars='Vehicle')
sns.barplot(x='value', y='Vehicle', hue='variable', data=bensin4)

#Histogram bensin dan Dist.Run menggunakan histogram
bensin1[["Fuel","Dist.Run"]].plot(kind="hist",
                                  alpha=0.7,
                                  bins=30,
                                  title="Histogram bensin dan Dist.Run",
                                  rot=45,
                                  grid=True,
                                  figsize=(12,8),
                                  fontsize=15,
                                  color=["#FF5733","#5C33FF"]
                                  )
plt.xlabel("Jarak(Meter)")
plt.ylabel("Bensin(liter)")

#Kendaraan, MPG dan Bensin menggunakan Lineplot
top_state = bensin1[["Vehicle"]]
top_state = bensin1[bensin1.Fuel.isin(top_state)]
#print(top_state)

bensin3 = bensin1[['Vehicle', 'MPG', 'Fuel']].groupby(['Vehicle', 'MPG'], as_index=False).agg('sum')
sns.lineplot(x='MPG', y='Fuel', hue='Vehicle', data=bensin3)

#Import train test split
from sklearn.model_selection import train_test_split as tts

#Korelasi merupakan suatu pengukuran sejauh mana nilai saling ketergantungan antar variabel.
#Causation merupakan hubungan antara sebab dan akibat antara dua variable.

bensin = bensin1[['Fuel']]
jarak = bensin1[['Dist.Run']]

X_train, X_test, y_train, y_test = tts(bensin, jarak, random_state=21, test_size = 0.2)

plt.scatter(X_train, y_train)
plt.xlabel('Bahan Bakar')
plt.ylabel('Jarak Tempuh')
plt.title('Konsumsi Bahan Bakar')
plt.show()

#
sns.regplot(x='Fuel', y='Dist.Run', data=bensin1)
plt.ylim(0,)
plt.xlabel('Bahan Bakar')
plt.ylabel('Jarak Tempuh')
plt.title('Konsumsi Bahan Bakar')
plt.show()

bensin1[['Fuel','Dist.Run']].corr()

from sklearn.linear_model import LinearRegression as lr
model_1 = lr()
model_1.fit(X_train,y_train)

#Perbandingan nilai antara y_test dan y_pred
y_pred = model_1.predict(X_test)

from sklearn import metrics

r2 = metrics.r2_score(y_test, y_pred)
print("Performansi model untuk set test")
print("-----------------------")
print("Nilai R2 adalah {}".format(r2))

#Nilai R2 adalah 0.00365337419021472
#skor merupakan hasil yang kurang baik karena y_test yang sempurna akan menghasilkan nilai R2 = 1

#Descriptive Statistic dengan boxplot
#sns.boxplot(x="Vehicle",y="Fuel",data=bensin1)
#plt.xticks(rotation=90)

#Grouping mengelompokkan dataframe dengan kombinasi unik
x = bensin1.iloc[:,3:5] #Fuel dan Dist.Run
y = bensin1.iloc[:,5:6] #MPG

X_train, X_test, y_train, y_test = tts(x, y, random_state=100, test_size = 0.2)

"""* X_train: Untuk menampung data source yang akan dilatih.
* X_test: Untuk menampung data target yang akan dilatih.
* y_train: Untuk menampung data source yang akan digunakan untuk testing.
* y_test: Untuk menampung data target yang akan digunakan untuk testing.

X dan y adalah nama variabel yang digunakan saat mendefinisikan data source dan data target. Parameter *test_size* digunakan untuk mendefinisikan ukuran data testing. Dalam contoh di atas, test_size=0.2 berarti data yang digunakan sebagai data testing adalah sebesar 20% dari keseluruhan dataset.

Perlu diketahui bahwa metode ini akan membagi train set dan test set secara random atau acak. Jadi, jika kita mengulang proses running, maka tentunya hasil yang didapat akan berubah-ubah. Untuk mengatasinya, kita dapat menggunakan parameter *random_state*
"""

from sklearn.linear_model import LogisticRegression

lg = LogisticRegression()
lg.fit(X_train,y_train)

y_pred = lg.predict(X_test)

# AUC singkatan dari Area Under Curve, sebuah daerah dalam kuva ROC. 
#Semakin mendekati nilai 1 untuk AUC, maka semakin baik juga model dalam menggambarkan dataset yang dimiliki.
from sklearn import metrics
auc = metrics.accuracy_score(y_test,y_pred)
print(f"Nilai AUC = {auc}")

# Nilai AUC = 0.08196721311475409, nilai yang kurang bagus. 
#setelah model selesai bisa menggunakan model tersebut untuk mengklasifikasikan jika ada data baru yang masuk

# mendapatkan korelasi di setiap fitur dalam dataset
corrmat = bensin1.corr()
top_corr_features = corrmat.index
plt.figure(figsize=(13,13))

# plot heatmap
h = sns.heatmap(bensin1[top_corr_features].corr(),annot=True,cmap="RdYlGn")

#Kesimpulan dari visualisasi heatmap pada gambar yaitu warna hijau menandakan relasi yang kuat atau berlarasan dan warna merah menandakan relasi yang lemah atau berkebalikan,

"""**Model Regresi Variabel Jamak**

**Memprediksi MPG vs Dist.Run dan Fuel dari semua kendaraan**
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
bensin1.head(10)

#Cek Statistika Dasar
bensin1.describe()

#Seleksi Data dan Tampilkan
cdf = bensin1[['Fuel','Dist.Run','MPG']]
cdf.head(10)

#Visualisasi Data yang Telah Diseleksi
viz = cdf[['Fuel','Dist.Run','MPG']]
viz.hist()
plt.show()
#Output

"""**Unsupervised Learning - Clustering**"""

#feature scaling
#standarisasi untuk kolom Bensin, MPG dan Jarak Tempuh

from sklearn.preprocessing import StandardScaler

bensin2 = bensin1[['Fuel','MPG','Dist.Run']].copy()

scaler = StandardScaler()

scaled_data = scaler.fit_transform(bensin2)
print(scaled_data)

bensin_scaled = pd.DataFrame(scaled_data, columns=['Fuel','MPG','Dist.Run'])
bensin_scaled

"""Elbow method untuk menemukan jumlah k kluster yang tepat"""

#elbow method beserta visualisasinya
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score

def elbowMethod(X, k_min=1, k_max=10, save=False):
    K_range = range(k_min,k_max+1)

    result = []
    for k in K_range:
        model = KMeans(n_clusters = k, random_state=20)
        model.fit(X)
        result.append(model.inertia_)
        
    fig, ax = plt.subplots(figsize=(15,8))
    
    ax.plot(K_range, result, marker='o')
    
    for i, value in enumerate(result):
        ax.text(i+1.15, value-0.005, round(value,2), fontsize=13, fontweight='bold')
    
    plt.xticks(K_range)
    plt.grid()
    plt.title('Elbow Method\n', fontsize=18)
    plt.xlabel('\nn-Cluster', fontsize=15)
    plt.ylabel('WCSS\n', fontsize=15)
    
    if save==True:
        plt.savefig('elbowMethod.png', dpi=200)
    
    plt.show()

#Silhouette method beserta visualisasinya

def silMethod(X, k_min=2, k_max=10, save=False):
    K_range2 = range(k_min,k_max+1)

    result_sm = []
    for k in K_range2:
        model2 = KMeans(n_clusters = k, random_state=20)
        model2.fit(X)
        labels = model2.labels_
    
        s_score = silhouette_score(X, labels, metric='euclidean')
        result_sm.append(s_score)
        
    fig2, ax2 = plt.subplots(figsize=(15,8))
    ax2.plot(K_range2, result_sm, marker='o')
    
    for i, value in enumerate(result_sm):
        ax2.text(i+2.15, value-0.005, round(value,2), fontsize=13, fontweight='bold')
    
    plt.xticks(K_range2)
    plt.grid()
    plt.title('Silhouette Method\n', fontsize=18)
    plt.xlabel('\nn-Cluster', fontsize=15)
    plt.ylabel('Silhouette Score\n', fontsize=15)
    if save==True:
        plt.savefig('silMethod.png', dpi=200)
    plt.show()

elbowMethod(bensin_scaled)

silMethod(bensin_scaled)

"""hasil plot
Dari kedua Plot tersebut kita mengetahui nilai terbaik adalah nilai k = 2 , Karena metode elbow yang paling stabil dan metode silhuette nilai puncaknya adalah 2

Gunakan k=4 (rekomendasi methode Elbow dan Silhuet), visualisasi
"""

from sklearn.cluster import KMeans

k2 = KMeans(n_clusters=2, random_state=9)

k2.fit(bensin_scaled)
bensin_scaled['lbl_k2'] = k2.labels_

bensin_scaled

bensin_scaled['lbl_k2'].value_counts()

"""Plot Hasil Clusterering dengan centroid"""

#Get the centroid
centroid_k2 = k2.cluster_centers_
centroid_k2

#X axis of Centroid
centroidX = centroid_k2[:,0]
centroidX

#Y axis of Centroid
centroidY = centroid_k2[:,1]
centroidY

#Z axis of Centroid
centroidZ = centroid_k2[:,2]
centroidZ

fig, ax = plt.subplots(figsize=(14,10))

#Create custom color dictionary
colorDict = {0:'#B88E8D', 1:'#60E1E0'}

#set axes bg color
ax.patch.set_facecolor('#CCCCCC')

#plot the data
ax.scatter(bensin_scaled['Dist.Run'], bensin_scaled['Fuel'],
           s=(bensin_scaled['MPG']+abs(bensin_scaled['Fuel'].min()))*100,
           c=bensin_scaled['lbl_k2'].map(colorDict), alpha=0.75, zorder=2)

#plot the centroids
ax.scatter(centroidX, centroidY,
           s=(centroidZ+abs(min(centroidZ))+0.7)*100,
           c='black', marker='o', zorder=3)

ax.set_title('Kluster MPG (Galon per Liter) (K=2)\n', fontsize=18, weight='bold')
ax.set_xlabel('\nJarak Jauh (meter)', fontsize=15, weight='bold')
ax.set_ylabel('Bensin (Liter)\n', fontsize=15, weight='bold')

#Create list of marker objects for legend parameter input
markers = [plt.Line2D([0,0],[0,0], color=color, marker='o', linestyle='') for color in colorDict.values()]

#Create the legend
plt.legend(markers, list(colorDict.keys())[:4], prop={'size':13},
           title='Cluster\n', title_fontsize=14)

plt.grid(color='white', zorder=0)

plt.show()

"""Plot data menggunakan skala asli"""

k2.feature_names_in_

bensin_2 = bensin1[['Fuel','MPG','Dist.Run']].copy()
bensin_2

bensin_scaled

fig, ax = plt.subplots(figsize=(14,10))

#Create custom color dictionary
colorDict = {0:'#B88E8D', 1:'#60E1E0'}

#set axes bg color
ax.patch.set_facecolor('#CCCCCC')

#plot the data
ax.scatter(bensin_2['Dist.Run'], bensin_2['Fuel'],
           s=bensin_2['MPG']*10,
           c=bensin_scaled['lbl_k2'].map(colorDict), alpha=0.75, zorder=2)

ax.set_title('Kluster MPG (Galon per Liter) (K=2)\n', fontsize=18, weight='bold')
ax.set_xlabel('\nJarak Jauh (meter))', fontsize=15, weight='bold')
ax.set_ylabel('Bensin (Liter)\n', fontsize=15, weight='bold')

#Create list of marker objects for legend parameter input
markers = [plt.Line2D([0,0],[0,0], color=color, marker='o', linestyle='') for color in colorDict.values()]

#Create the legend
plt.legend(markers, list(colorDict.keys())[:4], prop={'size':13},
           title='Cluster\n', title_fontsize=14)

plt.grid(color='white', zorder=0)

plt.show()

"""Plot dengan Centroid dalam Skala Asli """

#Display the centroids (scaled version)
centroid_k2

#Get the centroid in original scale
centroid_k2_originalScale = scaler.inverse_transform(centroid_k2)
centroid_k2_originalScale

#X axis of Centroid
centroidX = centroid_k2_originalScale[:,0]
centroidX

#Y axis of Centroid
centroidY = centroid_k2_originalScale[:,1]
centroidY

#Z axis of Centroid
centroidZ = centroid_k2_originalScale[:,2]
centroidZ

fig, ax = plt.subplots(figsize=(14,10))

#Create custom color dictionary
colorDict = {0:'#B88E8D', 1:'#60E1E0'}

#set axes bg color
ax.patch.set_facecolor('#CCCCCC')

#plot the data
ax.scatter(bensin_2['Dist.Run'], bensin_2['Fuel'],
           s=bensin_2['MPG']*10,
           c=bensin_scaled['lbl_k2'].map(colorDict), alpha=0.75, zorder=2)


#plot the centroids
ax.scatter(centroidX, centroidY, s=centroidZ*0.2, c='black', marker='o', zorder=3)

ax.set_title('Kluster MPG (Galon per Liter) (K=2)\n', fontsize=18, weight='bold')
ax.set_xlabel('\nJarak Jauh (meter)', fontsize=15, weight='bold')
ax.set_ylabel('Bensin (Liter)\n', fontsize=15, weight='bold')

#Create list of marker objects for legend parameter input
markers = [plt.Line2D([0,0],[0,0], color=color, marker='o', linestyle='') for color in colorDict.values()]

#Create the legend
plt.legend(markers, list(colorDict.keys())[:4], prop={'size':13},
           title='Cluster\n', title_fontsize=14)

plt.grid(color='white', zorder=0)

plt.show()

"""Dari hasil pengamatan, daerah merah menjelaskan bahwa Jarak Tempuh dari 2000 sampai 10000 meter membutuhkan jumlah bensin sekitar 0-5000 liter,

dan daerah hijau menjelaskan bahwa bahwa Jarak Tempuh dari 2000 sampai 4000 meter membutuhkan jumlah bensin sekitar 0-7000 liter.
"""

bensin_2.corr()

"""MPG memiliki korelasi dengan Dist.Run bernilai positif"""

sns.pairplot(bensin_2, x_vars='MPG', y_vars="Dist.Run",size=4, aspect=1, kind="scatter")
plt.show()

#Membuat object variabel linier regression
from sklearn.linear_model import LinearRegression
regressor = LinearRegression()

regressor.fit(X_train, y_train)

#Nilai slope/koefisien (m) dan intercept (b),
print(regressor.coef_)
print(regressor.intercept_)

"""Dari nilai m dan b diatas, kalau dimasukan ke dalam rumus persamaan menjadi:
#     **y = 0.00036x - 31.22**
"""

regressor.score(X_test,y_test)
#Model kita mendapatkan accuracy score sebesar 24.44%

import math
print('Correlation: ', math.sqrt(regressor.score(X_test,y_test)))

y_prediksi = regressor.predict(X_test)

"""Cetak nilai Mean Absolute Error, Mean Squared Error, dan Root Mean Squared Error"""

from sklearn import metrics 
 
print('Mean Absolute Error:', metrics.mean_absolute_error(y_test, y_prediksi))  
print('Mean Squared Error:', metrics.mean_squared_error(y_test, y_prediksi))  
print('Root Mean Squared Error:', np.sqrt(metrics.mean_squared_error(y_test, y_prediksi)))

plt.title('Comparison of Y values in test and the Predicted values')
plt.ylabel('Test Set')
plt.xlabel('Predicted values')
plt.plot(y_prediksi, '.', y_test, 'x')
plt.show()

"""**Model Evaluasi**"""

bensin3 = bensin1[["Fuel","Dist.Run","MPG","Type"]]
bensin3.head(3)

#Cek tabel Type
bensin3.loc[:,'Type'].tail(5)

#Konversi 'Type' String  to float
#bensin3['Type'] = pd.to_numeric(bensin3['Type'], errors='coerce')
#df['revenue'] = df['revenue'].apply(lambda x: float(x.split()[0].replace('$', '')))
bensin3['Type'] = bensin3['Type'].replace({'D':0, 'G':1})

bensin3

# hitung jumlah masing" data pada kolom survival_status
bensin3['Type'].value_counts()
# 0 adalah tipe D
# 1 adalah tipe G

X = bensin3[['Fuel','Dist.Run','MPG']]
y = bensin3['Type']

# test size= 25%, random state = 42, dan stratify = y
#import library train test split dan cross val
from sklearn.model_selection import train_test_split, cross_val_score

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42, stratify=y)

## pembuatan objek model
model_logReg = LogisticRegression(random_state = 42)

## latih model
model_logReg.fit(X_train, y_train)

## prediksi.
y_predict = model_logReg.predict(X_test)

# menghitung cross_val_score dengan scoring = 'roc_auc'
# parameter cv = 10 

score = cross_val_score(model_logReg, X, y, scoring = 'roc_auc', cv = 10)
print(score)

# cetak rata-rata nilai rata-rata auc score
score.mean()

# Prediksi data test dengan model yang telah kalian buat 
#import matriks
from sklearn import metrics

auc_score = metrics.roc_auc_score(y_test, y_predict)
auc_score

# import library confusion matrix dan classification report
from sklearn.metrics import classification_report, confusion_matrix

# apply confusion matrix dan cetak nilai confusion matrix
#cm = classification_report(y_test, y_predict, labels = (0,1))
bensin_cm = confusion_matrix(y_test, y_predict, labels = (0,1))
bensin_cm

# visualisasikan nilai confusion matrix ke dalam diagram heatmap
sns.heatmap(bensin_cm,annot=True, center=0)

"""Overfitting terjadi karena model yang dibuat terlalu fokus pada training dataset tertentu, hingga tidak bisa melakukan prediksi dengan tepat jika diberikan dataset lain yang serupa.

**Selanjutnya Tahap Deployment**
"""